<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <title>è½‰ç›¤æŠ½ç</title>
  <style>
    body {
      font-family: sans-serif;
      background: #f9f9f9;
      text-align: center;
      padding: 20px;
    }
    canvas {
      border: 3px solid #444;
      border-radius: 50%;
      margin: 20px 0;
    }
    textarea {
      width: 300px;
      height: 120px;
    }
    input, button {
      margin: 6px;
      padding: 8px 16px;
      font-size: 16px;
    }
    #result {
      font-size: 26px;
      color: #d63384;
      margin-top: 20px;
      white-space: pre-line;
    }
  </style>
</head>
<body>
  <h1>ğŸ¯ å¹³å‡æ©Ÿç‡è½‰ç›¤</h1>

  <p>æ¯è¡Œè¼¸å…¥ä¸€å€‹é¸é …ï¼š</p>
  <textarea id="optionsInput"></textarea><br>

  <label>æŠ½å–å¹¾å€‹é …ç›®ï¼š</label>
  <input type="number" id="drawCount" min="1" value="1"><br>

  <button id="drawBtn">é–‹å§‹æŠ½ç</button>
  <button id="clearBtn">æ¸…ç©º</button>
  <button id="saveBtn">ğŸ’¾ å„²å­˜</button>
  <button id="loadBtn">ğŸ“‚ è¼‰å…¥</button>

  <canvas id="wheel" width="400" height="400"></canvas>

  <div id="result"></div>

  <script>
    const canvas = document.getElementById('wheel');
    const ctx = canvas.getContext('2d');
    const input = document.getElementById('optionsInput');
    const drawBtn = document.getElementById('drawBtn');
    const clearBtn = document.getElementById('clearBtn');
    const resultDiv = document.getElementById('result');
    const drawCountInput = document.getElementById('drawCount');
    const saveBtn = document.getElementById('saveBtn');
    const loadBtn = document.getElementById('loadBtn');

    let fullOptions = []; // æ‰€æœ‰å‰©ä¸‹å¯æŠ½é¸é …
    let drawnResults = [];

    function parseOptions(text) {
      return text.trim().split('\n')
        .map(line => line.trim())
        .filter(x => x);
    }

    function drawWheel(options) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!options.length) return;
      const radius = canvas.width / 2;
      const anglePer = 2 * Math.PI / options.length;

      options.forEach((name, i) => {
        const angleStart = i * anglePer;
        const angleEnd = angleStart + anglePer;
        ctx.fillStyle = `hsl(${Math.random() * 360}, 70%, 60%)`;

        ctx.beginPath();
        ctx.moveTo(radius, radius);
        ctx.arc(radius, radius, radius, angleStart, angleEnd);
        ctx.lineTo(radius, radius);
        ctx.fill();

        ctx.save();
        ctx.translate(radius, radius);
        ctx.rotate(angleStart + anglePer / 2);
        ctx.fillStyle = '#000';
        ctx.font = '14px sans-serif';
        ctx.textAlign = 'right';
        ctx.fillText(name, radius - 10, 5);
        ctx.restore();
      });

      // æŒ‡é‡
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.moveTo(radius - 10, 10);
      ctx.lineTo(radius + 10, 10);
      ctx.lineTo(radius, 40);
      ctx.fill();
    }

    function spinToOption(optionName, options, callback) {
      const index = options.indexOf(optionName);
      const anglePer = 360 / options.length;
      const stopAngle = 360 - (index * anglePer + anglePer / 2);
      const finalAngle = 360 * 5 + stopAngle;

      let start = null;
      const duration = 3000;

      function animate(timestamp) {
        if (!start) start = timestamp;
        const progress = timestamp - start;
        const t = Math.min(progress / duration, 1);
        const ease = 1 - Math.pow(1 - t, 4);
        const currentRotation = (finalAngle * ease) * Math.PI / 180;

        ctx.save();
        ctx.translate(canvas.width / 2, canvas.height / 2);
        ctx.rotate(currentRotation);
        ctx.translate(-canvas.width / 2, -canvas.height / 2);
        drawWheel(options);
        ctx.restore();

        if (t < 1) {
          requestAnimationFrame(animate);
        } else {
          callback();
        }
      }

      requestAnimationFrame(animate);
    }

    drawBtn.addEventListener('click', () => {
      if (!fullOptions.length) {
        fullOptions = parseOptions(input.value);
      }
      const drawCount = parseInt(drawCountInput.value);
      if (fullOptions.length < drawCount || drawCount < 1) {
        alert('è«‹è¼¸å…¥æ­£ç¢ºæ ¼å¼èˆ‡è¶³å¤ é¸é …');
        return;
      }

      drawnResults = [];

      function drawNext(count) {
        if (count <= 0) {
          resultDiv.innerText = `ğŸ‰ æŠ½ä¸­ï¼š\n${drawnResults.join('\n')}`;
          input.value = fullOptions.join('\n');
          drawWheel(fullOptions);
          return;
        }

        const chosenIndex = Math.floor(Math.random() * fullOptions.length);
        const chosenName = fullOptions[chosenIndex];

        spinToOption(chosenName, fullOptions, () => {
          drawnResults.push(chosenName);
          fullOptions.splice(chosenIndex, 1); // ç§»é™¤å·²æŠ½é¸é …
          drawNext(count - 1);
        });
      }

      resultDiv.innerText = 'ğŸ”„ æ­£åœ¨æŠ½å–ä¸­...';
      drawNext(drawCount);
    });

    clearBtn.addEventListener('click', () => {
      input.value = '';
      resultDiv.innerText = '';
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      fullOptions = [];
      drawnResults = [];
    });

    saveBtn.addEventListener('click', () => {
      localStorage.setItem('wheelOptionsSimple', input.value);
      alert('âœ… å·²å„²å­˜é¸é …');
    });

    loadBtn.addEventListener('click', () => {
      const saved = localStorage.getItem('wheelOptionsSimple');
      if (saved) {
        input.value = saved;
        fullOptions = [];
        resultDiv.innerText = '';
        drawWheel(parseOptions(saved));
        alert('âœ… å·²è¼‰å…¥å„²å­˜é¸é …');
      } else {
        alert('âš ï¸ å°šæœªå„²å­˜éé¸é …');
      }
    });

    drawWheel([]);
  </script>
</body>
</html>
