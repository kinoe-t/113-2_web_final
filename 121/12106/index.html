<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>å‹•ç‰©æ¶ˆæ¶ˆæ¨‚</title>
  <style>
    body {
      font-family: "Microsoft JhengHei", sans-serif;
      background-color: #fff9f5;
      text-align: center;
    }
    #gameBoard {
      display: grid;
      grid-template-columns: repeat(9, 60px);
      grid-template-rows: repeat(9, 60px);
      gap: 2px;
      justify-content: center;
      margin-top: 20px;
    }
    .cell {
      width: 60px;
      height: 60px;
      font-size: 28px;
      background-color: #ffe4c4;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 6px;
      cursor: pointer;
      user-select: none;
    }
    .highlight {
      background-color: #ffc0cb !important;
    }
    .selected {
      border: 2px solid red;
    }
    #info {
      margin-top: 10px;
      font-size: 18px;
    }
  </style>
</head>
<body>
  <h1>ğŸ¾ å‹•ç‰©æ¶ˆæ¶ˆæ¨‚</h1>
  <p>é€£ç·šè¦å‰‡ï¼šä¸‰å€‹æœƒæ¶ˆé™¤ï¼Œå››å€‹ âœ ğŸ§¹ æƒæŠŠã€äº”å€‹ âœ ğŸ•¸ï¸ ç¶²å­ã€2x2 âœ âœˆï¸ é£›æ©Ÿ</p>
  <button onclick="startGame()">é–‹å§‹éŠæˆ²</button>
  <div id="info"></div>
  <div id="gameBoard"></div>

  <script>
    const EMOJIS = ["ğŸ·", "ğŸ±", "ğŸ¶", "ğŸ°", "ğŸ‘", "ğŸ˜"];
    const TOOLS = { broom: "ğŸ§¹", net: "ğŸ•¸ï¸", plane: "âœˆï¸" };
    const BOARD_SIZE = 9;
    let board = [], firstCell = null;
    let stepsLeft = 30;
    let targets = {}, cleared = {};
    let currentLevel = 0;

    const gameBoard = document.getElementById("gameBoard");
    const info = document.getElementById("info");

    const levelConfigs = [
      { steps: 30, target: { "ğŸ·": 10 } },
      { steps: 28, target: { "ğŸ±": 10, "ğŸ·": 10 } },
      { steps: 25, target: { "ğŸ°": 10, "ğŸ‘": 10 } },
      { steps: 25, target: { "ğŸ¶": 12, "ğŸ˜": 12 } },
      { steps: 22, target: { "ğŸ·": 10, "ğŸ‘": 10, "ğŸ±": 8 } },
      { steps: 20, target: { "ğŸ°": 12, "ğŸ±": 12, "ğŸ¶": 10 } },
      { steps: 18, target: { "ğŸ˜": 15, "ğŸ·": 15 } },
      { steps: 17, target: { "ğŸ°": 15, "ğŸ¶": 15 } },
      { steps: 16, target: { "ğŸ±": 18, "ğŸ‘": 18 } },
      { steps: 14, target: { "ğŸ˜": 20, "ğŸ¶": 20, "ğŸ±": 20 } }
    ];
    function updateInfo() {
      const goal = Object.entries(targets)
        .map(([k, v]) => `${k} ${cleared[k] || 0}/${v}`)
        .join("ï¼Œ");
      info.textContent = `ğŸ¯ ç›®æ¨™ï¼š${goal}ï½œå‰©é¤˜æ­¥æ•¸ï¼š${stepsLeft}`;
    }

    function getRandomEmoji() {
      return EMOJIS[Math.floor(Math.random() * EMOJIS.length)];
    }

    function generateBoard() {
      board = Array.from({ length: BOARD_SIZE }, () =>
        Array.from({ length: BOARD_SIZE }, () => getRandomEmoji()));
    }

    function drawBoard() {
      gameBoard.innerHTML = "";
      for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
          const cell = document.createElement("div");
          cell.className = "cell";
          cell.textContent = board[r][c];
          cell.dataset.row = r;
          cell.dataset.col = c;
          cell.onclick = () => handleClick(cell, r, c);
          gameBoard.appendChild(cell);
        }
      }
      updateInfo();
    }

    function isAdjacent(r1, c1, r2, c2) {
      return Math.abs(r1 - r2) + Math.abs(c1 - c2) === 1;
    }

    function swap(r1, c1, r2, c2) {
      [board[r1][c1], board[r2][c2]] = [board[r2][c2], board[r1][c1]];
    }

    function handleClick(cell, row, col) {
      const val = board[row][col];
      if ([TOOLS.broom, TOOLS.net, TOOLS.plane].includes(val)) {
        handleToolClick(row, col, val);
        return;
      }

      if (firstCell) {
        const r1 = +firstCell.dataset.row;
        const c1 = +firstCell.dataset.col;
        if (isAdjacent(r1, c1, row, col)) {
          swap(r1, c1, row, col);
          const matches = findMatches();
          if (matches.length > 0) {
            stepsLeft--;
            detectAndGenerateTool();
            drawBoard();
            removeMatches();
          } else {
            swap(r1, c1, row, col);
            drawBoard();
          }
          firstCell.classList.remove("selected");
          firstCell = null;
        } else {
          firstCell.classList.remove("selected");
          firstCell = cell;
          cell.classList.add("selected");
        }
      } else {
        firstCell = cell;
        cell.classList.add("selected");
      }
    }
    function findMatches() {
      const matches = [];

      // æ©«å‘é€£ç·š
      for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c <= BOARD_SIZE - 3; c++) {
          const e = board[r][c];
          if (!e || Object.values(TOOLS).includes(e)) continue;
          let count = 1;
          while (c + count < BOARD_SIZE && board[r][c + count] === e) count++;
          if (count >= 3) {
            for (let i = 0; i < count; i++) {
              matches.push([r, c + i]);
            }
            c += count - 1;
          }
        }
      }

      // ç›´å‘é€£ç·š
      for (let c = 0; c < BOARD_SIZE; c++) {
        for (let r = 0; r <= BOARD_SIZE - 3; r++) {
          const e = board[r][c];
          if (!e || Object.values(TOOLS).includes(e)) continue;
          let count = 1;
          while (r + count < BOARD_SIZE && board[r + count][c] === e) count++;
          if (count >= 3) {
            for (let i = 0; i < count; i++) {
              matches.push([r + i, c]);
            }
            r += count - 1;
          }
        }
      }

      // æ­£æ–¹å½¢ (2x2)
      for (let r = 0; r < BOARD_SIZE - 1; r++) {
        for (let c = 0; c < BOARD_SIZE - 1; c++) {
          const e = board[r][c];
          if (!e || Object.values(TOOLS).includes(e)) continue;
          if (board[r][c + 1] === e &&
              board[r + 1][c] === e &&
              board[r + 1][c + 1] === e) {
            matches.push([r, c], [r, c + 1], [r + 1, c], [r + 1, c + 1]);
          }
        }
      }

      return matches;
    }
    function detectAndGenerateTool() {
      // äº”é€£ç·š âœ ğŸ•¸ï¸ ç¶²å­
      for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c <= BOARD_SIZE - 5; c++) {
          const e = board[r][c];
          if (!e || Object.values(TOOLS).includes(e)) continue;
          if (board[r][c+1] === e && board[r][c+2] === e && board[r][c+3] === e && board[r][c+4] === e) {
            board[r][c+2] = TOOLS.net;
            return;
          }
        }
      }
      for (let c = 0; c < BOARD_SIZE; c++) {
        for (let r = 0; r <= BOARD_SIZE - 5; r++) {
          const e = board[r][c];
          if (!e || Object.values(TOOLS).includes(e)) continue;
          if (board[r+1][c] === e && board[r+2][c] === e && board[r+3][c] === e && board[r+4][c] === e) {
            board[r+2][c] = TOOLS.net;
            return;
          }
        }
      }

      // å››é€£ç·š âœ ğŸ§¹ æƒæŠŠ
      for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c <= BOARD_SIZE - 4; c++) {
          const e = board[r][c];
          if (!e || Object.values(TOOLS).includes(e)) continue;
          if (board[r][c+1] === e && board[r][c+2] === e && board[r][c+3] === e) {
            board[r][c+1] = TOOLS.broom;
            return;
          }
        }
      }
      for (let c = 0; c < BOARD_SIZE; c++) {
        for (let r = 0; r <= BOARD_SIZE - 4; r++) {
          const e = board[r][c];
          if (!e || Object.values(TOOLS).includes(e)) continue;
          if (board[r+1][c] === e && board[r+2][c] === e && board[r+3][c] === e) {
            board[r+1][c] = TOOLS.broom;
            return;
          }
        }
      }

      // 2x2 æ­£æ–¹å½¢ âœ âœˆï¸ é£›æ©Ÿ
      for (let r = 0; r < BOARD_SIZE - 1; r++) {
        for (let c = 0; c < BOARD_SIZE - 1; c++) {
          const e = board[r][c];
          if (!e || Object.values(TOOLS).includes(e)) continue;
          if (board[r][c+1] === e && board[r+1][c] === e && board[r+1][c+1] === e) {
            board[r][c] = TOOLS.plane;
            return;
          }
        }
      }
    }

    function handleToolClick(row, col, tool) {
      const targetsToClear = [];

     if (tool === TOOLS.broom) {
  const horizontal = Math.random() < 0.5;  // ä¸€åŠæ©Ÿç‡æ©«æ’ï¼ç›´æ’
  if (horizontal) {
    for (let i = 0; i < BOARD_SIZE; i++) targetsToClear.push([row, i]);  // æ©«æ’
  } else {
    for (let i = 0; i < BOARD_SIZE; i++) targetsToClear.push([i, col]);  // ç›´æ’
  }
}
       else if (tool === TOOLS.net) {
        const targetAnimal = getRandomEmoji();
        for (let r = 0; r < BOARD_SIZE; r++) {
          for (let c = 0; c < BOARD_SIZE; c++) {
            if (board[r][c] === targetAnimal) targetsToClear.push([r, c]);
          }
        }
      } else if (tool === TOOLS.plane) {
        for (let dr = -1; dr <= 1; dr++) {
          for (let dc = -1; dc <= 1; dc++) {
            const nr = row + dr, nc = col + dc;
            if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE)
              targetsToClear.push([nr, nc]);
          }
        }
        const targetAnimal = getRandomEmoji();
        outer: for (let r = 0; r < BOARD_SIZE; r++) {
          for (let c = 0; c < BOARD_SIZE; c++) {
            if (board[r][c] === targetAnimal) {
              targetsToClear.push([r, c]);
              break outer;
            }
          }
        }
      }

      // âœ… å…ˆè®Šè‰²
for (const [r, c] of targetsToClear) {
  const idx = r * BOARD_SIZE + c;
  const cell = gameBoard.children[idx];
  if (cell) cell.classList.add("highlight");
}

// âœ… å»¶é²å¾Œå†æ¶ˆé™¤
setTimeout(() => {
  for (const [r, c] of targetsToClear) {
    const val = board[r][c];
    if (targets[val]) cleared[val] = (cleared[val] || 0) + 1;
    board[r][c] = getRandomEmoji();
  }
  drawBoard();
  updateInfo();
  checkWin();
}, 400);

    }
    function removeMatches() {
      const matches = findMatches();
      if (matches.length === 0) return;

      detectAndGenerateTool(); // åœ¨æ¶ˆé™¤å‰å…ˆæ¨™ç¤ºé“å…·

      const seen = new Set();
      for (const [r, c] of matches) {
        seen.add(`${r},${c}`);
        const val = board[r][c];
        if (targets[val]) cleared[val] = (cleared[val] || 0) + 1;
      }

      for (const key of seen) {
        const [r, c] = key.split(",").map(Number);
        const idx = r * BOARD_SIZE + c;
        const cell = gameBoard.children[idx];
        if (cell) cell.classList.add("highlight");
      }

      setTimeout(() => {
        for (const key of seen) {
          const [r, c] = key.split(",").map(Number);
          board[r][c] = getRandomEmoji();
        }
        drawBoard();
        updateInfo();
        removeMatches(); // å†æ¬¡åµæ¸¬é€£é–
        checkWin();
      }, 400);
    }

    function checkWin() {
      const passed = Object.entries(targets).every(([emoji, goal]) => (cleared[emoji] || 0) >= goal);
      if (passed) {
        setTimeout(() => {
          alert("ğŸ‰ é€šé—œæˆåŠŸï¼");
          currentLevel++;
          if (currentLevel >= levelConfigs.length) {
            alert("ğŸ† ä½ è´äº†ï¼");
          } else {
            initLevel();
          }
        }, 300);
      } else if (stepsLeft <= 0) {
        setTimeout(() => {
          alert("ğŸ’¥ é—œå¡å¤±æ•—ï¼Œå†è©¦ä¸€æ¬¡ï¼");
          initLevel();
        }, 300);
      }
    }

    function initLevel() {
      const config = levelConfigs[currentLevel];
      stepsLeft = config.steps;
      targets = config.target;
      cleared = {};
      generateBoard();
      removeMatches(); // æ¸…é™¤åˆå§‹å¯é€£ç·š
      drawBoard();
    }

    function startGame() {
      currentLevel = 0;
      initLevel();
    }
  </script>
</body>
</html>
